package swizzle

import "core:fmt"
import "core:math"
import "core:strings"

main :: proc() {
    template_components : [5]string = {
        "n", //nil
        "x",
        "y",
        "z",
        "w",
    };

    fmt.println("//This file was automatically generated by swizzle_gen.odin\n");
    fmt.println("package swizzle");

    luhp: for c0, ic0 in template_components {
        min0 := ic0;


        for c1, ic1 in template_components {
            min1 := ic1 > min0 ? ic1 : min0;

            if (c0 == "n" && c1 == "n") do continue;

            nihl := "";
            if c0 == "n" || c1 == "n" do nihl = "n:E;";

            //explicit procedure overloading
            fmt.printf("\n%s%s :: proc {{", c0, c1);
            for i in min1..4 {
                fmt.printf("_%s%s%d_a,", c0, c1, i);
            }
            for i in min1..4 {
                fmt.printf("_%s%s%d_t,", c0, c1, i);
            }
            fmt.printf("};\n");
            
            // Permutations with generic array return
            // For swizzle with equal input and output length the same type will be returned
            for i in min1..4 {
                fmt.printf("_%s%s%d%s%d%s%s%s%s%s%s%s", c0, c1, i, "_a :: proc(i: $T/[", i,
                            i == 2 ? "]$E) -> T { " : "]$E) -> [2]E { ",
                            nihl,
                            i == 2 ? "return T{" : "return [2]E{",
                            c0 == "n" ? "n" : strings.concatenate({"i.",c0}), ",",
                            c1 == "n" ? "n" : strings.concatenate({"i.",c1}), "}; }\n"
                            );
            }
            // Permutation with specified array type return
            for i in min1..4 {
                fmt.printf("_%s%s%d%s%d%s%s%s%s%s%s%s", c0, c1, i, "_t :: proc(i: $T/[", i,
                            "]$E, $F: typeid/[2]E) -> F { ",
                            nihl,
                            "return F{",
                            c0 == "n" ? "n" : strings.concatenate({"i.",c0}), ",",
                            c1 == "n" ? "n" : strings.concatenate({"i.",c1}), "}; }\n"
                            );
            }

            for c2, ic2 in template_components {
                min2 := ic2 > min1 ? ic2 : min1;

                if (c0 == "n" && c1 == "n" && c2 == "n") do continue;

                nihl = "";
                if c0 == "n" || c1 == "n" || c2 == "n" do nihl = "n:E;";

                //explicit procedure overloading
                fmt.printf("\n%s%s%s :: proc {{", c0, c1, c2);
                for i in min2..4 {
                    fmt.printf("_%s%s%s%d_a,", c0, c1, c2, i);
                }
                for i in min2..4 {
                    fmt.printf("_%s%s%s%d_t,", c0, c1, c2, i);
                }
                fmt.printf("};\n");
            
                // Permutations with generic array return
                // For swizzle with equal input and output length the same type will be returned
                for i in min2..4 {
                    fmt.printf("_%s%s%s%d%s%d%s%s%s%s%s%s%s%s%s", c0, c1, c2, i, "_a :: proc(i: $T/[", i,
                                i == 3 ? "]$E) -> T { " : "]$E) -> [3]E { ",
                                nihl,
                                i == 3 ? "return T{" : "return [3]E{",
                                c0 == "n" ? "n" : strings.concatenate({"i.",c0}), ",",
                                c1 == "n" ? "n" : strings.concatenate({"i.",c1}), ",",
                                c2 == "n" ? "n" : strings.concatenate({"i.",c2}), "}; }\n"
                                );
                }
                // Permutation with specified array type return
                for i in min2..4 {
                    fmt.printf("_%s%s%s%d%s%d%s%s%s%s%s%s%s%s%s", c0, c1, c2, i, "_t :: proc(i: $T/[", i,
                                "]$E, $F: typeid/[3]E) -> F { ",
                                nihl,
                                "return F{",
                                c0 == "n" ? "n" : strings.concatenate({"i.",c0}), ",",
                                c1 == "n" ? "n" : strings.concatenate({"i.",c1}), ",",
                                c2 == "n" ? "n" : strings.concatenate({"i.",c2}), "}; }\n"
                                );
                }

                for c3, ic3 in template_components{
                    min3 := ic3 > min2 ? ic3 : min2;

                    if (c0 == "n" && c1 == "n" && c2 == "n" && c3 == "n") do continue;

                    nihl = "";
                    if c0 == "n" || c1 == "n" || c2 == "n" || c3 == "n" do nihl = "n:E;";

                    //explicit procedure overloading
                    fmt.printf("\n%s%s%s%s :: proc {{", c0, c1, c2, c3);
                    for i in min3..4 {
                        fmt.printf("_%s%s%s%s%d_a,", c0, c1, c2, c3, i);
                    }
                    for i in min3..4 {
                        fmt.printf("_%s%s%s%s%d_t,", c0, c1, c2, c3, i);
                    }
                    fmt.printf("};\n");
                    
                    // Permutations with generic array return
                    // For swizzle with equal input and output length the same type will be returned
                    for i in min3..4 {
                        fmt.printf("_%s%s%s%s%d%s%d%s%s%s%s%s%s%s%s%s%s%s", c0, c1, c2, c3, i, "_a :: proc(i: $T/[", i,
                                    i == 4 ? "]$E) -> T { " : "]$E) -> [4]E { ",
                                    nihl,
                                    i == 4 ? "return T{" : "return [4]E{",
                                    c0 == "n" ? "n" : strings.concatenate({"i.",c0}), ",",
                                    c1 == "n" ? "n" : strings.concatenate({"i.",c1}), ",",
                                    c1 == "n" ? "n" : strings.concatenate({"i.",c1}), ",",
                                    c2 == "n" ? "n" : strings.concatenate({"i.",c2}), "}; }\n"
                                    );
                    }
                    // Permutation with specified array type return
                    for i in min3..4 {
                        fmt.printf("_%s%s%s%s%d%s%d%s%s%s%s%s%s%s%s%s%s%s", c0, c1, c2, c3, i, "_t :: proc(i: $T/[", i,
                                    "]$E, $F: typeid/[4]E) -> F { ",
                                    nihl,
                                    "return F{",
                                    c0 == "n" ? "n" : strings.concatenate({"i.",c0}), ",",
                                    c1 == "n" ? "n" : strings.concatenate({"i.",c1}), ",",
                                    c1 == "n" ? "n" : strings.concatenate({"i.",c1}), ",",
                                    c2 == "n" ? "n" : strings.concatenate({"i.",c2}), "}; }\n"
                                    );
                    }

                }
            }
        }
    }
}